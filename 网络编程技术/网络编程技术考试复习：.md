# 网络编程技术考试复习：

## 第一章：

### OSI/RM参考模型与TCP/IP参考模型的基本原理和对比：

**OSI/RM参考模型：**

开放系统互连基本参考模型。

OSI参考模型中采用了七个层次的体系结构

1. 应用层
2. 表示层
3. 会话层
4. 运输层
5. 网络层
6. 数据链路层
7. 物理层

**TCP/IP参考模型：**

模型将数据链路层和物理层合并为网络接口层，将上三层合为应用层。

分为：

1. 应用层
2. 传输层
3. 网际层
4. 网络接口层

![image-20230410162138871](C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20230410162138871.png)

### 客户/服务器基本原理：

相互通信的网络程序通常可以分为两部分：

Client
Server

> 1. 客户端的数据有应用层的客户端软件产生
> 2. 数据从上向下经过协议栈的每一层，进行封装
> 3. 组合成帧，传递给底层网络设备。
> 4. 到达服务器的时候，反向拆分，还原为客户端发送的出示数据。

### 套接字基础：

**基本套接字数据结构、系统调用函数：**

套接字分为两种：

`IPv4:`

![image-20230410163402187](C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20230410163402187.png)

![image-20230410163616594](https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20230410163616594.png)

![image-20230410163627103](https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20230410163627103.png)

`IPv6:`

![image-20230410164053491](https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20230410164053491.png)

![image-20230410163814232](https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20230410163814232.png)

## 第二章：

### 套接字基本函数：

### 字节排序函数：

内存中存储字节有两种不同的方法，不同的系统采用的存储方式可能不同，因此定义了一个存储的标准：

![image-20230410164601143](https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20230410164601143.png)

主机字节序和网络字节序之间的相互转换，四个函数：

```C
#include<netinet/in.h>
uint16_t htons(uint16_t hosts);
uint32_t htonl(uint32_t hostl);
uint16_t ntohs(uint16_t nets);
uint32_t ntohl(uint32_t netl);
```

上述四个函数中，h代表host，n代表网络network，s代表短整型short，l代表长整型long

### IP地址转换函数：

通常人们比较喜欢用点分十进制来表示IP地址，而套接字地址结构中却需要用网络字节序的二进制值存储。

Linux系统提供了上述过程的地址转换函数。

```c
#include<arpa/inet.h>
in_addr_t inet_addr(const char *str);
inet inet_aton(const char *str,struct in_addr *numstr);
char *inet_ntoa(struct in_addr inaddr);
```

函数中a代表ASCII串，n代表数值（numeric）格式，是存在于套接字地址结构中的二进制值。

`inet_addr函数：`将字符串形式的IP地址转换为32位二进制的IP地址。str执行字符串形式的IP地址。函数调用成功，返回值为32位网络字节序的二进制值的IP地址。这个函数不对IP地址的有效性进行验证。

`inet_aton函数：`进行相同的转换，str指向字符串形式的IP地址。numstr指向转换后的32为网络字节序的ip地址，成功返回1，否则返回0。

`inet_ntoa函数：`32位二进制IP地址转换为字符串形式IP地址。

**只能处理IPv4**

## 第三章：

### TCP套接字编程：

使用TCP套接字编程可以实现基于TCP/IP协议的面向连接的通信，它分为i服务器端和客户端两部分。

![image-20230411110154532](https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20230411110154532.png)

服务器端实现的步骤：

1. 使用socket()函数创建套接字。
2. 为创建的套接字绑定到指定的地址结构，使用bind()函数。
3. listen()函数设置套接字为监听魔术，使服务器进入被动打开的状态。
4. 接收客户端的连接请求，建立连接，使用accept()函数。
5. 接收、应答客户端的数据请求，接收使用read()函数，应答使用write()函数。
6. 终止连接，使用close()函数。

### socket()函数：

函数定义：

```c
#include<sys/socket.h>
int socket(int family,int type,int protocol);
```

其中，family指明协议族，type参数指明产生套接字的类型，protocol参数是协议标志，一般在调用socket函数的时候将其置为0，但如果是原始套接字，就需要为protocol指定一个常值。

type参数：

1. SOCK_STREAM：字节流套接口，TCP使用
2. SOCK_DGRAM：数据报套接口，UDP使用
3. SOCK_RAM：原始套接口

可用组合：

![image-20230411111240079](https://cdn.jsdelivr.net/gh/Ho1L0w-By/Picturebed@main/img/image-20230411111240079.png)

调用socket函数的代码如下：

```c
#include<sys/socket.h>
int sockfd;
if((sockfd = socket(AF_INET,SOCK_STREAM,0)) == -1){
  
}
```

### connect()函数：

TCP客户端中，使用connect()函数来配置套接字函数，建立一个与TCP服务器的连接。

```c
#include<sys/socket.h>
int connect(int sockfd,const struct sockaddr *addr,socklen_t addrlen)
```

该函数用于激发TCP的三路我搜过程，建立连接。

sockfd是socket返回的套接字描述符。

第二个参数addr是指向服务器套接字地址结构的指针，如果是IPv4地址，server指向的就是一个sockaddr_in地址结构，在进行connect函数调用的时候，必须将sockaddr_in结构转换成通用地址结构，sockaddr，最后一个参数addrlen是该套接字地址结构的大小。

![image-20230411150903521](C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20230411150903521.png)

6行是为套接字地址结构server设置初始值0，就是使用bzero函数，将server这个套接字地址结构对应的内存空间清零。

7~9行为套接字地址结构中的成员赋值，包含ip，port，使用IPv4协议族。

调用connect()函数，然后强制性将IPv4转换为了通用套接字结构。

### bind()函数：

绑定函数为调用socket函数产生的套接字分配了一个本地协议地址，建立地址与套接字的对应关系，同时还会有对应的端口。

```c
#include<sys/socket.h>
int bind(int sockfd,struct sockaddr *server,socklen_len addrlen);
```

sockfd是套接字函数返回的套接字描述符，server参数是指向特定于协议的地址结构的指针，指定用于通信的本地协议地址，addrlen指定了该套接字地址结构的长度。

![image-20230411152528284](C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20230411152528284.png)

### listen()函数：

当调用函数socket创建一个陶杰字的时候，默认情况下他是一个主动套接字，也就是一个将调用connect发起连接的客户端套接字，所以对于TCP服务器，在绑定操作后，需要调用listen函数，将这个未连接的套接字转换为被动套接字，使它处在监听模式下。

```c
#include<sys/socket.h>
int listen(int sockfd,int backlog);
```

其中，backlog参数规定了请求队列中的最大连接个数，如果输入连接已满，则将拒绝连接请求。

### accept()函数： 

accept()函数使得服务器接收客户端的连接请求，它将完成队列中的队头条目返回给进程，并产生一个新的套接字描述符，这个新生成的描述符称之为“已连接套接字”。

```c
#include<sys/socket.h>
int accept(int listenfd,struct sockaddr *client,socklen_t *addrlen);
```

listenfd参数是由socket函数产生的套接字描述符，在调用accept()函数之前，就要用listen函数将套接字描述符转换为监听套接字。

client和addrlen参数用来返回连接对方的套接字地址结构和对应的结构长度，也就是返回客户端地址信息。

这里的addrlen是一个值，结果参数。

调用之前，将addrlen指针所指的整数值置为client所指的套接字地址结构长度。

所谓的地址结构题也就是IPv4协议族对应的本地协议地址的结构体。

![image-20230411165541019](C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20230411165541019.png)

6行可以得到client当前的长度，也就是客户端套接字地址结构体的长度。

### 数据传输函数：

**write()函数：**

因为套接字函数也是一种文件描述符，所以可以用文件读写函数来进行接收和发送工作。

write()函数是用于数据的发送：

```c
#include<unistd.h>
int write(int sockfd,char *buf,int len);
```

参数sockfd是套接字描述符。对于服务器来说，是accept()函数返回的已连接套接字描述符。

对于客户端时调用socket()函数返回第套接字描述符。

也就是说，对于服务端和客户端，fd是不一样的。

buf是指向一个用于发送信息的数据缓冲区，buf是指向一个用于发送信息的数据缓冲区。

len指明了传送数据缓冲区的大小。

**read()函数：**

```c
#include<unistd.h>
int read(int sockfd,char *buf,int len);
```

同上，一个是向缓冲区内写入，一个是从缓冲区内读取。

### 第四章：

![image-20230411210610938](C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20230411210610938.png)



 

### UDP套接字函数：

### recvfrom函数：

UDP使用recvfrom函数接收数据，它类似于标准的read，但是在recvfrom函数中，要指明目的地址，recvform函数如下：

```c
#include<sys/types.h>
#include<sys/socket.h>
ssize_t recvform(int sockfd,void *buf,size_t len,int flags,struct sockaddr *from,size_t *addrlen);
```

前三个是套接字描述符，指向一个数据缓冲区，读入的字节数。

flags参数是传输控制标志，0表示常规操作，所作的操作于read相同，MSG_OOB指明要读的是外带数据，MSG_PEEK可以查看刻度的数据而不读出，在接收数据后不会将这些数据丢弃。

from返回与之通信的对方的套接字地址结构，告诉用户接收到的数据包来自于谁。

addrlen是一个指向整数值的指针，存储在数据发送者的套接字地质结构中的字节数。

整个函数的返回值是接收的字节数。

### sendto()函数：

UDP使用sendto发送数据，类似标准的write，但是与recvfrom相同，要指明目的地。

```c
#include<sys/types.h>
#include<sys/socket.h>
ssize_t sedto(int sockfd,const void *buf,size_t len,int flags,const sturct sockaddr *to,int addrlen);
```

前三个没什么区别，

flags，0常规操作

MSG_DONTROUTE，告诉内核目的主机在直接连接的本地网络上，不需要查表

MSG_OOB，指明发送的是外带数据

同样也可以用于TCP，但是一般来说不这么用这两个。

## 第五章：

### 服务器分类：

服务器按处理方式可以分为迭代服务器和并发服务器两类。

每次只能处理一个客户请求的是迭代服务器。

并发可以处理多个。

![image-20230412092917660](C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20230412092917660.png)

![image-20230412101602897](C:\Users\Ho1L0w_By\AppData\Roaming\Typora\typora-user-images\image-20230412101602897.png)

Linux系统主要提供三种方式支持并发：

1. 线程
2. 进程
3. I/O多路复用。

### 多进程并发服务器：

进程的基本概念：

程序：存放在磁盘文件中可以执行的文件。

进程：程序的执行实例，是一个动态实体，是独立的任务。是”执行中的程序“。

进程拥有独立的地址空间，执行堆栈，文件描述符等。

Linux系统中可以同时存在多个进程，相互独立又相互影响。

进程是独立的，在未经允许的情况下，一个进程不能访问另一个进程的资源，一个进程崩溃不会造成其他进程崩溃。

但是可以通过IPC机制相互影响。



进程创建：

可以通过调用fork和vfork函数来创建一个新进程，需要进行资源拷贝。

```c
#include<unistd.h>
pid_t fork(void);
```

fork函数调用失败会返回1.

可能是已经有太多的进程，也可能是该实际用户ID的进程总数超过了系统限制。

如果调用成功，会返回两次，第一次是在父进程中，会返回子进程ID号，子进程中会返回0（因为1是创建失败）

### 进程终止：

进程终止存在两种可能性：

1. 父进程先于子进程终止
2. 子进程先于父进程终止

如果父进程先结束，则所有子进程的父进程被改为init进程。

如果子进程先结束，系统内核会保留一点信息，父进程可以通过wait()或是waitpid()函数获得终止信息。

```c
#include<sys/wait.h>
pid_t wait(int *statloc);
```

waitpid():

```
#include <sys/wait.h>
pid_t waitpid(pid_t pid ,int *statloc, int option);
```

pid等于-1，option等于0时，等同于wait()。

### 多进程并发服务器：

这样可以父进程只负责接收客户请求，而子进程只负责处理客户请求。

关闭不需要的描述符，既可以节省系统资源，又可以房子父子进程同时对共享描述符进程操作，造成不可知的后果。

### 多线程服务器：

线程是进程内的独立执行实体和调度单元，又可以被成为轻量级进程。

创建线程比进程快了100倍，一个进程内的所有线程共享相同的内存空间，全局变量，一个线程崩溃时，会影响同一进程中的其他线程。

### pthread_create()函数：

```
#include<pthread.h>
int pthread_create(pthread_t *tid,const pthread_attr_t *attr,void *(*func))
```

如果新线程创建成功，参数tid发牛新生成的线程ID，需要说明执行的函数，arg是调用的参数。

### 给新线程传递参数：

产生函数只能传递一个，要传递多个数据的时候，需要将所有数据封装在一个结构中，再将结构传递给执行函数。

如果要避免共用的话，可以使用maloc分配空间

### 线程安全函数：

Linux中提供了线程特定来取代静态变量TSD。

使用四个函数

1. pthread_key_create()
   在进程内分配一个TSD的关键字。
2. pthread_once()
   使用once参数所指向的遍历那给，保证每个进程只调用一次init函数，
3. pthread_setspecific()
   TSD关键字绑定一个与本线程相关的值，key是关键字，value是值。
4. pthread_getspecific()获取一个值。

### 使用函数参变量实现线程安全性：

使用函数的参变量来替代静态变量，这种方法非常简单，但是需要改变函数的原型，增加相应的参变量。

还必须为这些变量分配空间并且进行初始化。

